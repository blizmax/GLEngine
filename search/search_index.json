{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GLEngine About GLEngine is a complete game engine developed by Michael Buerger Using the following libraries: glfw (Windows, Input Handling, etc) glew (OpenGL Extension Wrangler) glm (OpenGL Mathematics) spdlog (Fast C++ logging, fancy colored text in console, easy formatting) stb_image.h (Single-file image loader) CPPModelLibrary (CPP library for loading model files) ImGui (Bloat-free Immediate Mode Graphical User interface for C++ with minimal dependencies) Installation If you are not contributing Grab the latest version of GLEngine here . This will download the repository in ZIP form, which automatically excludes unnecessary files. If you are contributing Clone the latest version of GLEngine git clone https : // github . com / popwser / GLEngine . git and see the contributing page. From there, download and install glew (instructions below). All libraries/binaries used within the engine are self-contained in the repository except for the following: glew ( required ) Installing glew-2.1.0 (required) Go to the GLEW Sourceforge page. Find the download for version 2.1.0 . Download the applicable file (win32.zip, zip, or tgz). Take the contained glew-2.1.0 folder and move it into the project directory. Within a terminal run: make make-project to build the necessary dependencies with CMake. Links Read the docs! https://glengine.readthedocs.org/en/latest/ Trello : https://trello.com/b/Pl9kCp8s/glengine GitHub : https://github.com/popwser/GLEngine","title":"Home"},{"location":"#glengine","text":"","title":"GLEngine"},{"location":"#about","text":"GLEngine is a complete game engine developed by Michael Buerger Using the following libraries: glfw (Windows, Input Handling, etc) glew (OpenGL Extension Wrangler) glm (OpenGL Mathematics) spdlog (Fast C++ logging, fancy colored text in console, easy formatting) stb_image.h (Single-file image loader) CPPModelLibrary (CPP library for loading model files) ImGui (Bloat-free Immediate Mode Graphical User interface for C++ with minimal dependencies)","title":"About"},{"location":"#installation","text":"","title":"Installation"},{"location":"#if-you-are-not-contributing","text":"Grab the latest version of GLEngine here . This will download the repository in ZIP form, which automatically excludes unnecessary files.","title":"If you are not contributing"},{"location":"#if-you-are-contributing","text":"Clone the latest version of GLEngine git clone https : // github . com / popwser / GLEngine . git and see the contributing page. From there, download and install glew (instructions below). All libraries/binaries used within the engine are self-contained in the repository except for the following: glew ( required )","title":"If you are contributing"},{"location":"#installing-glew-210-required","text":"Go to the GLEW Sourceforge page. Find the download for version 2.1.0 . Download the applicable file (win32.zip, zip, or tgz). Take the contained glew-2.1.0 folder and move it into the project directory. Within a terminal run: make make-project to build the necessary dependencies with CMake.","title":"Installing glew-2.1.0 (required)"},{"location":"#links","text":"Read the docs! https://glengine.readthedocs.org/en/latest/ Trello : https://trello.com/b/Pl9kCp8s/glengine GitHub : https://github.com/popwser/GLEngine","title":"Links"},{"location":"license/","text":"License MIT License Copyright (c) 2019 Michael Buerger Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"","title":"License"},{"location":"license/#mit-license","text":"Copyright (c) 2019 Michael Buerger Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"contributing/","text":"Contributors Read This! Some Useful Tools Installing valgrind (not required) Ubuntu/Debian : sudo apt install valgrind macOS : Install homebrew then run brew install valgrind Testing Your Code The following commands can be run from a terminal in the project directory : Tip When adding new cpp files to the engine, re-running make make-project is required for them to be added to the CMake project (as it automatically finds all CPP files in the project). make all or make : Says what each make function does make make-project : Builds necessary dependencies with CMake make build-project : Builds the engine make execute-project : Executes main.cpp make build-execute project : Runs build-project then execute-project make qea : Runs make-project then build-project then execute-project make line-count : Queries line counts of various parts of the engine's code make clean : Runs all of the following clean commands make clean-bin : Clears bin directory of engine (not including sub-directories) Tip Running make qea is a fast way to run all of the necessary make commands when testing your code. GitHub pipeline Note GLEngine is currently in a chaotic stage of development, so contributing by formal means is difficult. If you are interested in contributing, or have any ideas, please reach out to me! Once the project reaches a stable stage, the pipeline will change drastically. Currently: The transfer1 branch is the first place all changes end up, commits are frequent and chaotic. The other two branches are currently ignored. When the project reaches a more stable stage: The develop branch and the release branch will not except commits directly, and will only be mutable through pull requests. To make changes, a new branch with one of two prefixes will be created: issue- feature- Once a feature or issue branch is ready to be merged, it will be rebased upon the develop branch and then a pull request will be created from the feature or issue branch into the develop branch . The release branch will only recieve pull requests when major milestones are reached. For me, this means when the project is in a good place in terms of functionality. Useful Tidbits Note main.cpp is only for testing purposes and is not built into the static library.","title":"Contributing"},{"location":"contributing/#contributors-read-this","text":"","title":"Contributors Read This!"},{"location":"contributing/#some-useful-tools","text":"","title":"Some Useful Tools"},{"location":"contributing/#installing-valgrind-not-required","text":"Ubuntu/Debian : sudo apt install valgrind macOS : Install homebrew then run brew install valgrind","title":"Installing valgrind (not required)"},{"location":"contributing/#testing-your-code","text":"The following commands can be run from a terminal in the project directory : Tip When adding new cpp files to the engine, re-running make make-project is required for them to be added to the CMake project (as it automatically finds all CPP files in the project). make all or make : Says what each make function does make make-project : Builds necessary dependencies with CMake make build-project : Builds the engine make execute-project : Executes main.cpp make build-execute project : Runs build-project then execute-project make qea : Runs make-project then build-project then execute-project make line-count : Queries line counts of various parts of the engine's code make clean : Runs all of the following clean commands make clean-bin : Clears bin directory of engine (not including sub-directories) Tip Running make qea is a fast way to run all of the necessary make commands when testing your code.","title":"Testing Your Code"},{"location":"contributing/#github-pipeline","text":"Note GLEngine is currently in a chaotic stage of development, so contributing by formal means is difficult. If you are interested in contributing, or have any ideas, please reach out to me! Once the project reaches a stable stage, the pipeline will change drastically. Currently: The transfer1 branch is the first place all changes end up, commits are frequent and chaotic. The other two branches are currently ignored. When the project reaches a more stable stage: The develop branch and the release branch will not except commits directly, and will only be mutable through pull requests. To make changes, a new branch with one of two prefixes will be created: issue- feature- Once a feature or issue branch is ready to be merged, it will be rebased upon the develop branch and then a pull request will be created from the feature or issue branch into the develop branch . The release branch will only recieve pull requests when major milestones are reached. For me, this means when the project is in a good place in terms of functionality.","title":"GitHub pipeline"},{"location":"contributing/#useful-tidbits","text":"Note main.cpp is only for testing purposes and is not built into the static library.","title":"Useful Tidbits"},{"location":"gettingstarted/","text":"Getting Started First of all, make sure you follow the installation instructions here . GLFW and OpenGL (with glew) GLEngine uses GLFW 3.3 for platform-independent window and input handling, and glew 2.1.0 for including modern OpenGL functionality. They must be included in the following order: #include <GL/glew.h> #include <GLFW/glfw3.h> Tip Any time you want to use GLFW or OpenGL methods or defines, simply importing GLEngine/include/graphics/graphics.hpp will include everything for you in the right order. Creating Windows If you want to manually handle the creation and destruction of GLFW windows, please take a look at the following: GLFW Window Guide GLEngine contains it's own system for creating and handling one or multiple GLFW windows called the WindowHandler . You should only create one of these per application. The following snippet shows you how to create your own WindowHandler (initializing GLFW for you) and then create your own window. WindowHandler windowHandler = WindowHandler (); // Initialize GLFW and WindowHandler std :: vector < int > windowHintNames = std :: vector < int > (); std :: vector < int > windowHintValues = std :: vector < int > (); windowHintNames . push_back ( GLFW_RESIZABLE ); windowHintValues . push_back ( GL_FALSE ); // Turn off resizing windowHintNames . push_back ( GLFW_CONTEXT_VERSION_MAJOR ); windowHintValues . push_back ( 3 ); // OpenGL version 3.x windowHintNames . push_back ( GLFW_CONTEXT_VERSION_MINOR ); windowHintValues . push_back ( 3 ); // OpenGL version x.3 // Together these two window hints set the Window to use OpenGL version 3.3 GLFWwindow * window ; = windowHandler . CreateWindow ( 1280 , 720 , \"Window Title\" , nullptr , nullptr , windowHintNames , windowHintValues ); See the WindowHandler reference for more details Every window holds a reference to it's own OpenGL version, as the OpenGL context at any time in your application is based on what window you are rendering to. Note CreateWindow will call glfwMakeContentCurrent on the GLFWwindow* it is creating for you. When you want to manually switch the glfw context, you have to call glfwMakeContextCurrent(yourWindow) yourself. Initializing glew At any point after the initialization of GLFW , you can initialize glew. This can be achieved with the following code (eventually this will be handled by the renderer): GLenum err = glewInit (); if ( GLEW_OK != err ) { std :: cout << \"Error: \" << glewGetErrorString ( err ) << std :: endl ; } Note Please note that you should try to use GLEngine's logging (with spdlog ) when possible. See the engine and application logging section. Engine and Application Logging GLEngine utilizes spdlog to handle all of it's logging. CPPModelLibrary also does. This is because spdlog handles two important features: Rust-lang like formatting , and level based logging: meaning that all logging can separated into different levels of importance (and colors!).","title":"Getting Started"},{"location":"gettingstarted/#getting-started","text":"First of all, make sure you follow the installation instructions here .","title":"Getting Started"},{"location":"gettingstarted/#glfw-and-opengl-with-glew","text":"GLEngine uses GLFW 3.3 for platform-independent window and input handling, and glew 2.1.0 for including modern OpenGL functionality. They must be included in the following order: #include <GL/glew.h> #include <GLFW/glfw3.h> Tip Any time you want to use GLFW or OpenGL methods or defines, simply importing GLEngine/include/graphics/graphics.hpp will include everything for you in the right order.","title":"GLFW and OpenGL (with glew)"},{"location":"gettingstarted/#creating-windows","text":"If you want to manually handle the creation and destruction of GLFW windows, please take a look at the following: GLFW Window Guide GLEngine contains it's own system for creating and handling one or multiple GLFW windows called the WindowHandler . You should only create one of these per application. The following snippet shows you how to create your own WindowHandler (initializing GLFW for you) and then create your own window. WindowHandler windowHandler = WindowHandler (); // Initialize GLFW and WindowHandler std :: vector < int > windowHintNames = std :: vector < int > (); std :: vector < int > windowHintValues = std :: vector < int > (); windowHintNames . push_back ( GLFW_RESIZABLE ); windowHintValues . push_back ( GL_FALSE ); // Turn off resizing windowHintNames . push_back ( GLFW_CONTEXT_VERSION_MAJOR ); windowHintValues . push_back ( 3 ); // OpenGL version 3.x windowHintNames . push_back ( GLFW_CONTEXT_VERSION_MINOR ); windowHintValues . push_back ( 3 ); // OpenGL version x.3 // Together these two window hints set the Window to use OpenGL version 3.3 GLFWwindow * window ; = windowHandler . CreateWindow ( 1280 , 720 , \"Window Title\" , nullptr , nullptr , windowHintNames , windowHintValues ); See the WindowHandler reference for more details Every window holds a reference to it's own OpenGL version, as the OpenGL context at any time in your application is based on what window you are rendering to. Note CreateWindow will call glfwMakeContentCurrent on the GLFWwindow* it is creating for you. When you want to manually switch the glfw context, you have to call glfwMakeContextCurrent(yourWindow) yourself.","title":"Creating Windows"},{"location":"gettingstarted/#initializing-glew","text":"At any point after the initialization of GLFW , you can initialize glew. This can be achieved with the following code (eventually this will be handled by the renderer): GLenum err = glewInit (); if ( GLEW_OK != err ) { std :: cout << \"Error: \" << glewGetErrorString ( err ) << std :: endl ; } Note Please note that you should try to use GLEngine's logging (with spdlog ) when possible. See the engine and application logging section.","title":"Initializing glew"},{"location":"gettingstarted/#engine-and-application-logging","text":"GLEngine utilizes spdlog to handle all of it's logging. CPPModelLibrary also does. This is because spdlog handles two important features: Rust-lang like formatting , and level based logging: meaning that all logging can separated into different levels of importance (and colors!).","title":"Engine and Application Logging"},{"location":"reference/","text":"Reference gives usage and argument information on every class and class member/function, along with simple usage examples. graphics reference input reference math reference logging reference","title":"Reference"},{"location":"reference/#graphics-reference","text":"","title":"graphics reference"},{"location":"reference/#input-reference","text":"","title":"input reference"},{"location":"reference/#math-reference","text":"","title":"math reference"},{"location":"reference/#logging-reference","text":"","title":"logging reference"},{"location":"reference/graphics/","text":"WindowHandler Image ImageHandler Model Texture ModelHandler Transform","title":"WindowHandler"},{"location":"reference/graphics/#windowhandler","text":"","title":"WindowHandler"},{"location":"reference/graphics/#image","text":"","title":"Image"},{"location":"reference/graphics/#imagehandler","text":"","title":"ImageHandler"},{"location":"reference/graphics/#model","text":"","title":"Model"},{"location":"reference/graphics/#texture","text":"","title":"Texture"},{"location":"reference/graphics/#modelhandler","text":"","title":"ModelHandler"},{"location":"reference/graphics/#transform","text":"","title":"Transform"},{"location":"reference/input/","text":"","title":"Input"},{"location":"reference/logging/","text":"","title":"Logging"},{"location":"reference/math/","text":"","title":"Math"}]}